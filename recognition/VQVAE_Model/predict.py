import os
import random
import time

import torch
from PIL import Image
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from pixelCNN import *
from dataset import *

def eval():
    '''
    Only evaluate after all the training
    An animation of all the recorded generated pictures will be shown.
    :return: None
    '''

    if not os.path.exists("./Pic"):
        raise NotImplementedError
    else:
        image_dir = "./Pic"

        image_files = [f for f in os.listdir(image_dir) if f.endswith('.jpg')]

        image_files.sort()

        # Create a figure and axis for the animation
        fig, ax = plt.subplots()
        ax.set_axis_off()
        fig.tight_layout()

        # Function to update the animation
        def update(frame):
            img = Image.open(os.path.join(image_dir, image_files[frame]))
            ax.clear()
            ax.imshow(img)

        # Create the animation
        animation = FuncAnimation(fig, update, frames=len(image_files), repeat=False)
        plt.show()

def generate():
    '''
    Generate Images using Pixel CNN, only run this after train.py is finished and pixelCNN.py is finished running
    Save pictures under Pic folder
    :return: Nothing should be returned
    '''
    model_ = PixelCNN()

    # Load the trained model
    tqdm_bar = tqdm(range(10000))
    model_.load_state_dict(torch.load("./Model/pixelCNN.pth"))
    for eq in tqdm_bar:
        train_img_, _ = next(iter(training_loader))
        quantized = model_(train_img_)

        # Call the Decoder in modules.py
        decoder = Decoder(EMBEDDING_DIM, HIDDEN_DIM, NUM_RESIDUAL_LAYER, RESIDUAL_HIDDEN_DIM)

        # Show the trained images using decoder
        x_re = decoder(quantized)

        # Save the images generated by PixelCNN
        save_image(x_re, "./Pic/PixelCNN_generate.jpg")  # Save image at ./Pic dir


if __name__ == "__main__":

    # Choose eval to see the reconstruction
    eval()

    time.sleep(10)

    # Choose generate to see the generation
    generate()
